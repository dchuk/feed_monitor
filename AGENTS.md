# Repository Guidelines

refer to ./ai/project_overview.md for full scope of this project

## Library Documentation

- Use Context7 MCP constantly to look up fresh documentation for any task you're looking to complete, especially tasks that rely on using libraries or gems

### Project Dependencies & context7 links

- Feedjirra - https://context7.com/feedjira/feedjira

## Project Structure & Module Organization

The engine follows the Rails mountable layout generated by `rails plugin new feed_monitor --mountable`. Runtime code lives under `app/` (controllers, jobs, views) and is namespaced as `FeedMonitor`. Long-lived services, adapters, and instrumentation helpers belong in `lib/feed_monitor/`. Generator templates and install scripts reside in `lib/generators/feed_monitor/`. Tests sit in `test/`, with fixtures under `test/fixtures/feeds/`, and the dummy host app in `test/dummy/` for integration coverage. Keep shared UI assets under `app/assets/` and engine configuration in `config/initializers/`.

## Build, Test, and Development Commands

Run `bin/setup` to install gems, prepare the dummy database, and compile Tailwind. Use `bin/rails test` (or `bundle exec rake test`) for the full MiniTest suite, including system tests through the dummy app. During feature work, `bin/dev` starts the dummy app with Solid Queue workers and Tailwind watcher. Trigger a feed ingest locally with `bin/rails runner 'FeedMonitor::FetchFeeds.call'` once the fetcher service lands.

## Background Job Defaults

- FeedMonitor ensures Solid Queue is the default adapter when the host app is still using the async adapter, but respects any explicit `ActiveJob` configuration already in place. Override queues/concurrency via `FeedMonitor.configure`.
- Queue names are namespaced (`feed_monitor_fetch`/`feed_monitor_scrape` by default) and automatically honor host `queue_name_prefix`. Use `FeedMonitor.queue_name(:fetch)` helpers inside jobs.
- Dashboard queue metrics read directly from Solid Queue tables via `FeedMonitor::Jobs::SolidQueueMetrics`. Host apps must install the Solid Queue migrations (reuse the engine's `20251009140000_create_solid_queue_tables.rb` or run `rails solid_queue:install`) for the card to surface ready/scheduled/failed counts; otherwise the UI falls back to an availability warning. Mission Control remains optional for deeper drill-downs.
- The dummy host keeps Solid Queue tables in the primary database via `20251009140000_create_solid_queue_tables.rb`. Real apps can either reuse that migration or run `rails solid_queue:install` to manage a dedicated queue database—Mission Control expects one of those setups before it can surface data.
- Recurring schedules live in `config/recurring.yml`, scheduling `FeedMonitor::ScheduleFetchesJob` each minute plus the scraping scheduler every two minutes. Override the schedule path with `bin/jobs --recurring_schedule_file=...` (or `SOLID_QUEUE_RECURRING_SCHEDULE_FILE`) and disable recurring runners with `SOLID_QUEUE_SKIP_RECURRING=true` or `bin/jobs --skip-recurring`.
- Hosts that need to wrap Solid Queue command execution can set `config.recurring_command_job_class` in the generated initializer to point at their custom job class.

## Configuration DSL

- `FeedMonitor.configure` now exposes structured namespaces:
  - `config.http` for Faraday timeouts, retry policy, proxy, and default headers. Per the [Faraday retry docs](https://github.com/lostisland/faraday/blob/main/docs/middleware/index.md), middleware options map 1:1 to the settings we surface (max retries, interval, backoff, statuses).
  - `config.scrapers` registers/overrides adapters by name; adapters must inherit from `FeedMonitor::Scrapers::Base` and are discovered before constant lookup.
  - `config.retention` supplies global defaults for `items_retention_days`, `max_items`, and the pruning strategy (`:destroy` or `:soft_delete`). Runtimes treat blank source fields as “inherit from config”.
- Install generator and dummy initializer list all knobs with comments—update those when slicing future roadmap items.

## Retention Defaults

- Per-source retention settings live on `FeedMonitor::Source` (`items_retention_days` and `max_items`). Negative values are rejected; blank means unlimited.
- `FeedMonitor::Items::RetentionPruner` runs after every fetch via `FeedMonitor::Fetching::FetchRunner`, pruning stale items and their associated content/logs while keeping counter caches in sync.
- Age-based rules prune items when their published timestamp (or `created_at` fallback) is older than the configured window. Count-based rules keep the newest N items.
- `FeedMonitor::ItemCleanupJob` batches retention pruning across sources and can soft delete records (`rake feed_monitor:cleanup:items` honours `SOFT_DELETE=true`, `SOURCE_IDS=1,2`). `FeedMonitor::LogCleanupJob` prunes old fetch/scrape logs (`rake feed_monitor:cleanup:logs`, override `FETCH_LOG_DAYS` / `SCRAPE_LOG_DAYS`).
- Nightly recurring entries in `config/recurring.yml` enqueue both cleanup jobs by default; adjust schedules or disable via Solid Queue overrides as needed.

## Coding Style & Naming Conventions

Use two-space indentation and Ruby 3.3 syntax. Keep engine classes under the `FeedMonitor::` namespace; new modules should mirror their directory, e.g., `lib/feed_monitor/fetching/pipeline.rb`. Favor service objects ending in `Service`, jobs ending in `Job`, and background channels ending in `Channel`. Rails defaults handle formatting, but run `bundle exec rubocop` (configured via `.rubocop.yml`) before opening a PR. For views, stick with ERB and Tailwind utility classes.

## Testing Guidelines

MiniTest drives coverage (`test/models`, `test/controllers`, `test/system`). Name files with `_test.rb` and wrap suites in `module FeedMonitor`. Add VCR cassettes under `test/vcr_cassettes/` when touching HTTP clients, and record new fixtures with descriptive names like `source_fetch_success.yml`. Target >90% coverage for new services and include regression tests for bug fixes. Use `bin/rails test test/system` before changing UI flows.

## Commit & Pull Request Guidelines

Adopt imperative commit messages in the format `scope: action`, e.g., `sources: enforce URL normalization`. Group unrelated work into separate commits. PRs should describe context, summarise the slice delivered, list validation steps (`bin/rails test`, manual fetch run), and reference roadmap items from `.ai/tasks.md`. Include screenshots or console output when altering UI or background jobs. Request at least one review and ensure CI completes before merge.

## Security & Configuration Tips

Store secrets (API keys, webhook tokens) in `config/credentials/` and never commit plain-text values. When adding HTTP endpoints or webhooks, default to Solid Queue middleware for retries and respect the allowlist in `config/feed_monitor.yml`. Document new environment variables in `config/application.yml.sample` and call out any migrations that impact host apps.

# Clean coding guidelines

Object Orientated Design: You should write code that embraces change. Here’s how…

SRP: A class should do the smallest possible useful thing; it should have a single responsibility. A class that has more than one responsibility is difficult to reuse. SRP requires that a class be cohesive, that everything the class does be highly related to its purpose. A class that is easy to reuse will make the application easier to change.

Methods, like classes, should have a single responsibility. All of the same reasons apply, having just one responsibility makes them easy to change and easy to reuse.

DRY: DRY code tolerates change because any change in behaviour can be made by changing code in just one place.

Depend on behaviour not data:

Hide instance variables by wrapping them in a method, an attr_reader. The method changes a variable from data ( which is referenced all over) to behaviour (which is defined once). This means if you need to adjust the data you only have to make a change in one place.

Hide data structures using the Struct class.

Minimise Dependencies: An object depends on another object if, when one object changes, the other might be forced to change in turn. An object has a dependency when it knows:

The name of another class.

The name of a message that it intends to send to someone other than self.

The arguments that a message requires.

The order of those arguments.

Dependency Injection: Addresses the first dependency. It decouples two objects by moving the creation of object_A outside of object_B eg:

object_A.new(1,2,object_B.new)

Encapsulation: Addresses the second dependency. Create wrapper methods so that external messages are isolated in one place. The wrapper method is called throughout the class, rather than sending messages externally.

Use hashes for initialization arguments: this addresses the final dependencies.

Depend on things that change less often than you do

## Agent Notes (2025-10-08)

- Finished roadmap section 05.03 (structured fetch error handling). Added `FeedMonitor::Fetching::FetchError` hierarchy, expanded `FeedFetcher` error handling, and ensured instrumentation payloads include success/error context.
- Fetch attempts now always create `FetchLog` records and update `Source` failure state; added MiniTest coverage for timeout, HTTP 404, and malformed feed scenarios.
- Relevant tests: `bundle exec rails test test/lib/feed_monitor/fetching/feed_fetcher_test.rb` and full suite via `bundle exec rails test` (both passing).
- Next roadmap item is 05.04 (not started). Untracked tmp dir `test/lib/tmp` can be safely ignored if it reappears.

## Agent Notes (2025-10-09)

- Introduced `FeedMonitor::Scrapers::Base`, establishing the scraper adapter contract and Result object. Subclasses merge default, source, and invocation settings (HashWithIndifferentAccess) and must return a Result with status/html/content/metadata. Use `FeedMonitor::Scrapers::Base.call(item:, source:, settings:, http:)` to execute adapters.
- Added Readability scraper adapter leveraging FeedMonitor::HTTP, Nokolexbor, and ruby-readability. Supports override selectors via `scrape_settings[:selectors]`, records extraction metadata including strategy and inferred status, and returns structured failure results on HTTP errors.
- Extracted scraper HTTP fetching and parsing into dedicated collaborators (`FeedMonitor::Scrapers::Fetchers::HttpFetcher` and `FeedMonitor::Scrapers::Parsers::ReadabilityParser`). The adapter now orchestrates these services, simplifying future parser additions while keeping failure metadata consistent.
- Added Readability scraper adapter leveraging FeedMonitor::HTTP, Nokolexbor, and ruby-readability. Supports override selectors via `scrape_settings[:selectors]`, records extraction metadata including strategy and inferred status, and returns structured failure results on HTTP errors.
- Phase 07.03 complete: introduced `FeedMonitor::ItemContent` table with one-to-one association, virtual accessors on `Item`, and migration that backfills existing scraped data while dropping legacy columns. Clearing both fields now removes the content row. Run `bundle exec rails db:migrate` in host apps after upgrading.
- Phase 07.04 complete: added `FeedMonitor::Scraping::ItemScraper` service with log recording, manual scrape controls in the item admin, and a dedicated scraping configuration section on the source form. Item show page now highlights content comparisons, status badges, and recent scrape errors. System coverage updated to exercise the manual scraping flow.
- Phase 08.02 complete: created `FeedMonitor::FetchFeedJob`, introduced `FeedMonitor::Fetching::FetchRunner` with Postgres advisory locking, and added a temporary `ScrapeItemJob` stub so new items from auto-scrape sources are queued with `scrape_status` set to `pending`. Manual fetch UI now reuses the runner, and tests cover job retry behavior plus follow-up scraping enqueue (`bundle exec rails test test/lib/feed_monitor/fetching/fetch_runner_test.rb`, `bundle exec rails test test/jobs/feed_monitor/fetch_feed_job_test.rb`, and `bundle exec rails test test/lib/feed_monitor/fetching/feed_fetcher_test.rb`).
- Phase 08.03 complete: implemented `FeedMonitor::Scraping::Enqueuer` with deduplication/auto-scrape guards, promoted `FeedMonitor::ScrapeItemJob` to execute `ItemScraper`, and updated the manual item view to enqueue jobs instead of running scrapes inline. Added unit coverage for the enqueuer/job plus refreshed the manual scrape system test (`bundle exec rails test test/lib/feed_monitor/scraping/enqueuer_test.rb test/jobs/feed_monitor/scrape_item_job_test.rb test/system/items_test.rb test/lib/feed_monitor/fetching/fetch_runner_test.rb`).
- Phase 08.04 complete: manual "Fetch Now" now queues `FetchFeedJob` via `FetchRunner.enqueue`, dashboard shows live queue metrics from `FeedMonitor::Jobs::Visibility`, and optional Mission Control link appears when configured. System tests updated to assert job enqueues (`test/system/sources_test.rb`, `test/system/items_test.rb`, `test/system/dashboard_test.rb`); run `bundle exec rails test test/system` after UI tweaks.
- Install generator now also creates `config/initializers/feed_monitor.rb` with documented defaults for queue settings, metrics, and Mission Control hooks. Update the initializer if future configuration options are added.
- `FeedMonitor.mission_control_dashboard_path` now validates that the configured path exists before rendering a dashboard link, preventing 404s when Mission Control isn't mounted yet. Template comments outline how to mount the engine when enabling it.
- `test/dummy/bin/dev` now runs the Rails server with `BUNDLE_GEMFILE` pointing at the dummy app, so dummy-only gems (like mission_control-jobs) load correctly while the Tailwind watcher still uses the engine's Gemfile.
