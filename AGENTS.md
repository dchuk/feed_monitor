# Repository Guidelines

refer to ./ai/project_overview.md for full scope of this project

## Library Documentation

- Use Context7 MCP constantly to look up fresh documentation for any task you're looking to complete, especially tasks that rely on using libraries or gems

### Project Dependencies & context7 links

- Feedjirra - https://context7.com/feedjira/feedjira

## Project Structure & Module Organization

The engine follows the Rails mountable layout generated by `rails plugin new feed_monitor --mountable`. Runtime code lives under `app/` (controllers, jobs, views) and is namespaced as `FeedMonitor`. Long-lived services, adapters, and instrumentation helpers belong in `lib/feed_monitor/`. Generator templates and install scripts reside in `lib/generators/feed_monitor/`. Tests sit in `test/`, with fixtures under `test/fixtures/feeds/`, and the dummy host app in `test/dummy/` for integration coverage. Keep shared UI assets under `app/assets/` and engine configuration in `config/initializers/`.

## Build, Test, and Development Commands

Run `bin/setup` to install gems, prepare the dummy database, and compile Tailwind. Use `bin/rails test` (or `bundle exec rake test`) for the full MiniTest suite, including system tests through the dummy app. During feature work, `bin/dev` starts the dummy app with Solid Queue workers and Tailwind watcher. Trigger a feed ingest locally with `bin/rails runner 'FeedMonitor::FetchFeeds.call'` once the fetcher service lands.

## Coding Style & Naming Conventions

Use two-space indentation and Ruby 3.3 syntax. Keep engine classes under the `FeedMonitor::` namespace; new modules should mirror their directory, e.g., `lib/feed_monitor/fetching/pipeline.rb`. Favor service objects ending in `Service`, jobs ending in `Job`, and background channels ending in `Channel`. Rails defaults handle formatting, but run `bundle exec rubocop` (configured via `.rubocop.yml`) before opening a PR. For views, stick with ERB and Tailwind utility classes.

## Testing Guidelines

MiniTest drives coverage (`test/models`, `test/controllers`, `test/system`). Name files with `_test.rb` and wrap suites in `module FeedMonitor`. Add VCR cassettes under `test/vcr_cassettes/` when touching HTTP clients, and record new fixtures with descriptive names like `source_fetch_success.yml`. Target >90% coverage for new services and include regression tests for bug fixes. Use `bin/rails test test/system` before changing UI flows.

## Commit & Pull Request Guidelines

Adopt imperative commit messages in the format `scope: action`, e.g., `sources: enforce URL normalization`. Group unrelated work into separate commits. PRs should describe context, summarise the slice delivered, list validation steps (`bin/rails test`, manual fetch run), and reference roadmap items from `.ai/tasks.md`. Include screenshots or console output when altering UI or background jobs. Request at least one review and ensure CI completes before merge.

## Security & Configuration Tips

Store secrets (API keys, webhook tokens) in `config/credentials/` and never commit plain-text values. When adding HTTP endpoints or webhooks, default to Solid Queue middleware for retries and respect the allowlist in `config/feed_monitor.yml`. Document new environment variables in `config/application.yml.sample` and call out any migrations that impact host apps.

# Clean coding guidelines

Object Orientated Design: You should write code that embraces change. Here’s how…

SRP: A class should do the smallest possible useful thing; it should have a single responsibility. A class that has more than one responsibility is difficult to reuse. SRP requires that a class be cohesive, that everything the class does be highly related to its purpose. A class that is easy to reuse will make the application easier to change.

Methods, like classes, should have a single responsibility. All of the same reasons apply, having just one responsibility makes them easy to change and easy to reuse.

DRY: DRY code tolerates change because any change in behaviour can be made by changing code in just one place.

Depend on behaviour not data:

Hide instance variables by wrapping them in a method, an attr_reader. The method changes a variable from data ( which is referenced all over) to behaviour (which is defined once). This means if you need to adjust the data you only have to make a change in one place.

Hide data structures using the Struct class.

Minimise Dependencies: An object depends on another object if, when one object changes, the other might be forced to change in turn. An object has a dependency when it knows:

The name of another class.

The name of a message that it intends to send to someone other than self.

The arguments that a message requires.

The order of those arguments.

Dependency Injection: Addresses the first dependency. It decouples two objects by moving the creation of object_A outside of object_B eg:

object_A.new(1,2,object_B.new)

Encapsulation: Addresses the second dependency. Create wrapper methods so that external messages are isolated in one place. The wrapper method is called throughout the class, rather than sending messages externally.

Use hashes for initialization arguments: this addresses the final dependencies.

Depend on things that change less often than you do

## Agent Notes (2025-10-08)

- Finished roadmap section 05.03 (structured fetch error handling). Added `FeedMonitor::Fetching::FetchError` hierarchy, expanded `FeedFetcher` error handling, and ensured instrumentation payloads include success/error context.
- Fetch attempts now always create `FetchLog` records and update `Source` failure state; added MiniTest coverage for timeout, HTTP 404, and malformed feed scenarios.
- Relevant tests: `bundle exec rails test test/lib/feed_monitor/fetching/feed_fetcher_test.rb` and full suite via `bundle exec rails test` (both passing).
- Next roadmap item is 05.04 (not started). Untracked tmp dir `test/lib/tmp` can be safely ignored if it reappears.

## Agent Notes (2025-10-09)

- Introduced `FeedMonitor::Scrapers::Base`, establishing the scraper adapter contract and Result object. Subclasses merge default, source, and invocation settings (HashWithIndifferentAccess) and must return a Result with status/html/content/metadata. Use `FeedMonitor::Scrapers::Base.call(item:, source:, settings:, http:)` to execute adapters.
- Added Readability scraper adapter leveraging FeedMonitor::HTTP, Nokolexbor, and ruby-readability. Supports override selectors via `scrape_settings[:selectors]`, records extraction metadata including strategy and inferred status, and returns structured failure results on HTTP errors.
- Extracted scraper HTTP fetching and parsing into dedicated collaborators (`FeedMonitor::Scrapers::Fetchers::HttpFetcher` and `FeedMonitor::Scrapers::Parsers::ReadabilityParser`). The adapter now orchestrates these services, simplifying future parser additions while keeping failure metadata consistent.
- Added Readability scraper adapter leveraging FeedMonitor::HTTP, Nokolexbor, and ruby-readability. Supports override selectors via `scrape_settings[:selectors]`, records extraction metadata including strategy and inferred status, and returns structured failure results on HTTP errors.
